// File: DataOracle.sol

// SPDX-License-Identifier: MIT
// Specifies the license for the code.
pragma solidity ^0.8.20;

// We import the Ownable contract from the OpenZeppelin library.
// This provides a secure and battle-tested mechanism for access control,
// ensuring only the contract "owner" (the deployer) can submit data.
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title DataOracle
 * @author Your Name (Generated by AI)
 * @notice This contract serves as an immutable on-chain registry for data hashes.
 * It implements a "Proof-of-History" pattern where a trusted owner (a Python script)
 * can submit hashes of off-chain data. Once submitted, a hash for a specific
 * name and date cannot be altered or overwritten.
 *
 * Architecture:
 * - Uses OpenZeppelin's Ownable for secure, simple access control.
 * - A nested mapping `dataHashes` stores the data.
 * - An event `DataHashSubmitted` logs all submissions for off-chain indexing.
 * - `submitDataHash` is the "write" function, restricted to the owner.
 * - `getHash` is the "read" function, open to the public for verification.
 */
contract DataOracle is Ownable {
    
    // --- State Variables ---

    /**
     * @notice The core data structure for storing data hashes.
     * It's a nested mapping:
     * 1. The first key (string) is a human-readable identifier (e.g., "AAPL", "BTC-USD").
     * 2. The second key (uint256) is a numerical representation of the date (e.g., 20231025).
     * 3. The value (bytes32) is the SHA-256 hash of the data payload.
     *
     * We use `bytes32` because it's gas-efficient and perfectly fits a SHA-256 hash.
     * The mapping is public, which automatically creates a getter function.
     * However, we provide an explicit `getHash` function for clarity.
     */
    mapping(string => mapping(uint256 => bytes32)) public dataHashes;

    // --- Events ---

    /**
     * @notice Emitted when a new data hash is successfully submitted.
     * @param name The indexed identifier (e.g., "AAPL") for the data.
     * @param date The indexed date (e.g., 20231025) for the data.
     * @param hash The `bytes32` hash of the data that was stored.
     *
     * We 'index' `name` and `date` to allow clients to easily filter
     * and search for these events off-chain.
     */
    event DataHashSubmitted(string indexed name, uint256 indexed date, bytes32 hash);

    // --- Functions ---

    /**
     * @notice Creates the contract and sets the deployer as the initial owner.
     * The `Ownable` constructor handles setting `msg.sender` as the owner.
     * We pass the deployer's address to the Ownable constructor.
     */
    constructor() Ownable(msg.sender) {
        // The owner is set by the Ownable constructor.
        // No additional logic is needed here.
    }

    /**
     * @notice Submits a data hash for a given name and date.
     * @dev This function can ONLY be called by the contract owner.
     * It enforces the "Proof-of-History" by ensuring that data, once written,
     * cannot be overwritten.
     *
     * @param name The identifier for the data (e.g., "AAPL").
     * @param date The numerical date (e.g., 20231025).
     * @param hash The `bytes32` hash of the off-chain data.
     */
    function submitDataHash(string memory name, uint256 date, bytes32 hash) 
        public 
        onlyOwner // Modifier: Ensures only the owner can call this.
    {
        // --- Input Validation & Security Check ---
        
        // This is the most critical line for immutability.
        // We check if the storage slot for this name/date combination is empty.
        // In Solidity, the default value for `bytes32` is 32 zero bytes (0x0).
        // If `dataHashes[name][date]` is NOT zero, it means data has
        // already been submitted, and we must revert the transaction.
        require(
            dataHashes[name][date] == 0, 
            "Data for this date and name already submitted"
        );

        // --- State Change ---

        // Store the hash in its designated slot in the mapping.
        dataHashes[name][date] = hash;

        // --- Logging ---

        // Emit an event to log this action on the blockchain.
        // This allows UIs, dashboards, and other services to listen for
        // new data submissions without having to query the contract state directly.
        emit DataHashSubmitted(name, date, hash);
    }

    /**
     * @notice Retrieves a stored data hash for a given name and date.
     * @dev This is a public `view` function, meaning anyone can call it for free
     * (if called off-chain) or for a very low gas cost (if called by
     * another contract). It does not modify the state.
     *
     * @param name The identifier for the data (e.g., "AAPL").
     * @param date The numerical date (e.g., 20231025).
     * @return bytes32 The stored hash. Will return 0x0 if no hash is stored.
     */
    function getHash(string memory name, uint256 date) 
        public 
        view 
        returns (bytes32) 
    {
        // Simply return the value from the mapping.
        // If no data exists at this slot, it will return the default
        // value for `bytes32`, which is 0x0.
        return dataHashes[name][date];
    }
}